\chapter{Desarrollo}

El desarrollo del juego se puede separar en tres grandes bloques diferentes entre sí: Diseño, arte y programación.


%----- Diseño --------------------------------------
%---------------------------------------------------
\section{Diseño}


%----- Arte ----------------------------------------
%---------------------------------------------------
\section{Arte}
Todo el arte del juego se ha hecho mediante los programas Autodesk 3ds Max para el modelado y Photoshop para la creación de la texturas.

\subsection{Escenario}

\subsection{Personajes}
El diseño de los personajes (figura \ref{fig:personajes}) fue sacado de varios universos, pero sobre todo se ha intentado que los personajes tengas un estilo realista dentro de la ambientación. Se ha buscado siempre que creen una ambientación visual coherente y armónica.

\begin{figure}
\begin{center}
\includegraphics[scale=0.75]{figures/development/personajes.eps}
\end{center}
\emph{\caption{Todos los personajes del juego}\label{fig:personajes}}
\end{figure}

\subsubsection{Caperucita}

Ficha técnica:
\begin{itemize}
\item Nombre: Caperucita
\item Tipo: Personaje jugable / Protagonista
\item Altura: 1.50m
\item Polígonos: 6185 (7800 con las armas)
\item Huesos: 36 + 4 huesos independientes
\item Ánimaciones: 12
\end{itemize}

Caperucita Roja es el personaje principal del juego, la protagonista del cuento de Charles Perrault. Es el personaje más complicado que se ha creado ya que es el modelo animado que lleva el jugador y, por lo tanto, el que más se ve. Antes de empezar la creación de Caperucita se han buscado muchas referencias para inspirar el arte (figura \ref{fig:caperu_insipration}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.55]{figures/development/caperu_insipration.eps}
\end{center}
\emph{\caption{Referencias de arte sobre Caperucita}\label{fig:caperu_insipration}}
\end{figure}

El diseño de Caperucita (figura \ref{fig:caperu_model}) requería mucha reflexión porque se le añadió una falda, un trabajo complicado en el momento de animar el personaje. La falda tiene cuatro huesos independientes asociados, que permiten la animación de la ropa. Estos huesos se han unido al \emph{mesh} del personaje con un sistema de resorte (\emph{Spring System}), una opción de 3ds Max que permite a huesos independientes seguir el movimiento de un bípedo y rebotar en función de la fuerza de impacto de las animaciones del personaje. Con esta técnica aplicada, se ha conseguido que la falda sigua al cuerpo con un movimiento harmónico. 

\begin{figure}
\begin{center}
\includegraphics[scale=0.65]{figures/development/caperu_model.eps}
\end{center}
\emph{\caption{Proceso de creación de Caperucita}\label{fig:caperu_model}}
\end{figure}

Las armas que lleva el jugador estan unidas a la misma malla de Caperucita por motivos de rendimiento. Así pues, la textura de las armas también está en el mismo fichero que la textura del personaje.

El personaje tiene textura de normales y oclusión.

Las animaciones creadas para Caperucita son:
\begin{itemize}
\item Idle. Posición estática del personaje respirando.
\item Run. Movimiento de correr.
\item Jump. Salto hacia adelante.
\item Hit. Cuando se recibe un golpe.
\item Defense. Postura de defensa.
\item Combo de ataque 1. Secuencia de tres golpes con las armas. Se termina con un golpe potente horizontal.
\item Combo de ataque 2. Secuencia de tres golpes. Los golpes son más potentes. El combo finaliza con un ataque circular devastador.
\end{itemize}

\subsubsection{El Lobo}
Ficha técnica:
\begin{itemize}
\item Nombre: The Wolf
\item Tipo: Enemigo / Enemigo final
\item Altura: 3.25m
\item Polígonos: 2226
\item Huesos: 28
\item Animaciones: 9
\end{itemize}

El Lobo fue el primer enemigo que se creó para el juego. Se ha exagerado el tamaño respecto al tamaño de Caperucita para que parezca giganteso y dar sensacion de miedo y ansiedad en el combate final.

Este enemigo fue diseñado con pocos polígonos y huesos ya que al ser el primer enemigo, sirvió también como prueba técnica para el motor (figura \ref{fig:wolf_model}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figures/development/wolf_model.eps}
\end{center}
\emph{\caption{Proceso de creación del Lobo}\label{fig:wolf_model}}
\end{figure}

Su diseño está inspirado en dibujos y fotografías de criaturas de hombres lobo (figura \ref{fig:wolf_inspiration}). Se han hecho varios esbozos para concluir en un resultado final, un enemigo bípedo y corpulento.
\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figures/development/wolf_inspiration.eps}
\end{center}
\emph{\caption{Referencias para el Lobo}\label{fig:wolf_inspiration}}
\end{figure}

El personaje tiene textura de normales y oclusión.

Las animaciones creadas para el Lobo son:
\begin{itemize}
\item Idle. Posición estática del personaje respirando pesadamente.
\item Walk. El personaje camina.
\item Run. El enemigo corre.
\item Hit. Recibe un golpe.
\item Die. El Lobo se cae y muere.
\item Defense. Postura de defensa.
\item Howl. Aulla para llamar a más enemigos.
\item Attack / Combo. Ataque del personaje.
\item Attack / Run. Ataque corriendo. 
\end{itemize}

\subsubsection{Conejo}
Ficha técnica:
\begin{itemize}
\item Nombre: Bad Rabbit
\item Tipo: Enemigo ligero
\item Altura: 1.25m
\item Polígonos: 2672
\item Huesos: 34 + 4 huesos independientes
\item Animaciones: 10
\end{itemize}

El conejo es un enemigo ligero y rápido, con ataques ágiles pero no muy fuertes. Se han sacado referencias de varios universos para crear el personaje (figura \ref{fig:rabbit_inspiration}). La idea del personaje es darle un aspecto siniestro y demencial, un conejo diabólico. Se caracteriza por su postura curva y rota. Con este aspecto de locura y con la agilidad que tiene, se intenta transmitir una sensación de agobio al jugador.

\begin{figure}
\begin{center}
\includegraphics[scale=0.75]{figures/development/rabbit_inspiration.eps}
\end{center}
\emph{\caption{Referencias para el conejo}\label{fig:rabbit_inspiration}}
\end{figure}

Está diseñado con más polígonos y huesos que el Lobo (figure \ref{fig:rabbit_model}). Se añadieron cuatro huesos independientes a las orejas para conseguir más realismo en los movimientos de la cabeza. Estos huesos son necesarios para crear el \emph{overlapping} en las animaciones.

\begin{figure}
\begin{center}
\includegraphics[scale=0.85]{figures/development/rabbit_model.eps}
\end{center}
\emph{\caption{Proceso de creación del conejo}\label{fig:rabbit_model}}
\end{figure}

El personaje tiene textura de normales y oclusión.

Las animaciones del conejo son:
\begin{itemize}
\item Idle. Posición estática del personaje respirando.
\item Walk. El personaje camina.
\item Run. El enemigo corre.
\item Pasos laterales. El modelo animado se desplaza lateralmente.
\item Jump. Un pequeño salto.
\item Hit. Recibe un golpe.
\item Die. Se cae y muere.
\item Defense. Postura de defensa.
\item Attack 1. El conejo hace un golpe directo con las uñas
\item Attack 2. El golpe es circular con las uñas.
\end{itemize}

\subsubsection{Ciervo}
Ficha técnica:
\begin{itemize}
\item Nombre: Bad Deer
\item Tipo: Enemigo pesado
\item Altura: 2m
\item Polígonos: 2701
\item Huesos: 33
\item Animaciones: 9
\end{itemize}

Este personaje ha sido más complejo de diseñar dade que no existen muchas referencias de enemigos similares (figura \ref{fig:deer_inspiration}). Se hico una mezcla de varias referencias para obtener el resultado final. La idea general en el diseño del ciervo era la de tener un enemigo más grande que el conejo, más pesado pero a la vez, mucho más destructivo. Aunque tenga una gran altura, su delgada corpulencia le permite moverse con velocidad. Igual que el conejo, se le quería dar un aspeco demencial, extraño y deformado, como por ejemplo su tamaño distinto para sus ojos.

\begin{figure}
\begin{center}
\includegraphics[scale=0.65]{figures/development/deer_inspiration.eps}
\end{center}
\emph{\caption{Referencias para el ciervo}\label{fig:deer_inspiration}}
\end{figure}

El personaje tiene textura de normales y oclusión. Para dar efecto de pelo, se mezcló dos colores en la textura para sí intentar imitar la piel de los animales y para dar la sensación de locura. No se le ha añadido ningún hueso independiente tal y como ha pasado con otros personajes (\ref{fig:deer_model}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.75]{figures/development/deer_model.eps}
\end{center}
\emph{\caption{Proceso de creación del ciervo}\label{fig:deer_model}}
\end{figure}

Las animaciones del ciervo son:
\begin{itemize}
\item Idle. Posición estática del personaje respirando pesadamente.
\item Walk. El personaje camina.
\item Run. El enemigo corre.
\item Hit. Recibe un golpe.
\item Die. El ciervo muere.
\item Howl. Aulla para llamar a más enemigos.
\item Defense. Postura de defensa.
\item Attack Punch. Dos golpes con los brazos.
\item Attack Run. El personaje baja el torso y carga su presa con sus cuernos.
\end{itemize}

%----- Programación --------------------------------
%---------------------------------------------------
\section{Programación}
\emph{Boc Engine} (nombre del motor) es el motor de videojuegos desarrollado en C++ para el máster y el juego. Este motor ha sido creado tanto con tecnología propia como de terceros, que nos ha facilitado tener una base sólida para poder construir todas las partes que componen un videojuego.

\emph{Boc Engine} ha sido dividido en diferentes proyectos, cada uno especializado en un ámbito distinto (gráficos, sonido, GUI,...) pero interconectados entre sí.

La tecnología de terceros utilizada en el motor es la siguiente:
\begin{itemize}
\item Boost. Utilizado para fines varios.
\item Cal3D. Para las animaciones de los modelos animados.
\item Lua/Luabind. Utilizado como lenguaje de \emph{scripting} en el juego.
\item PhysX. Utilizado para el motor de físicas del juego.
\item Theora-Ogg / OpenAL. Para la reproducción de ficheros de video.
\item Wwise. Para la reproducción de sonido.
\item XML. Para guardar toda la información del juego.
\end{itemize}

Toda la estructura del motor, y del juego en sí, está basada en ficheros XML. El lenguaje XML permite externalizar los parámetros del motor, así como también guardar toda la información referente al juego.

COmo entorno de desarrollo utilizado ha sido Microsoft Visual Studio 2010 para todo el motor y Notepad++ para editar ficheros XML y Lua.

\subsection{Gráficos}
Los aspectos donde se ha hecho más enfasi durante la programación de los gráficos a sido con la iluminación, las sombras, las partículas y los efectos de post procesado. 

\subsubsection{Iluminación y sombras}
La iluminación del juego se ha hecho con \emph{forward shading}. Se ha implementado la luz con está técnica porque en el juego hay una gran cantidad de elementos con transparencia y sólo una luz direccional que representa el Sol. Esta técnica es más eficiente con transparencias y pocas luces. 

Las sombras (figura \ref{fig:sombras}) se han hecho mediante la combinación de dos técnicas, \emph{Variance Shadow Mapping} \cite{variance} y \emph{Cascade Shadow Mapping} \cite{cascaded}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{figures/development/sombras.eps}
\end{center}
\emph{\caption{Escena final con las sombras}\label{fig:sombras}}
\end{figure}

La técnica del \emph{Variance Shadow Mapping} ha sido utilizada para crear las sombras. Para conseguir sombras detalladas en todo el escenario, se ha hecho con \emph{Cascaded Shadow Mapping}. Esta técnica crea mapas de sombras según la distancia del jugador. Así, las sombras más próximas al jugador tienen más detalle que las más alejadas, pero al tener gran distancia no se percibe el cambio de calidad. Para el juego usamos tres mapas de sombras a diferentes distancias (figura \ref{fig:csm} y \ref{fig:csm_mapas}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figures/development/csm.eps}
\end{center}
\emph{\caption{Mapas de sombras creados con Cascaded Shadow Mapping}\label{fig:csm}}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{figures/development/csm_mapas.eps}
\end{center}
\emph{\caption{Diferentes mapas de sombras aplicados a la escena. El rojo es el mapa con más calidad y el azul el que tiene menos calidad.}\label{fig:csm_mapas}}
\end{figure}

\subsubsection{Partículas}

El sistema de partículas diseñado se conforma de cuatro bloques principales: \emph{Settings}, \emph{systems}, \emph{emitters} y \emph{shader}.

\begin{itemize}
\item \emph{Settings}. Define el comportamiento de unas partículas. Tiene la información específica de como tiene que funcionar un sistema de partículas.
\item \emph{Systems}. Es el responsable de mantener un orden sobre qué partículas se tienen que renderizar y cúales no. También informa al \emph{shader} sobre que textura utilizar y cuantas partículas dibujar.
\item \emph{Emitter}. Se asocia con un sistema de partículas y define en que posición del mundo deben ejecutarse las partículas.
\item \emph{Shader}. Se encarga del renderizado principal de las partículas, así como también de los cálculos asociados a las mismas, como por ejemplo la velocidad o la posición de una partícula concreta, entre otros parámetros.
\end{itemize}

\subsubsection{Post procesado}

Los efectos de post procesados son aquellos que se aplican una vez se ha renderizado toda la escena con la iluminación. Se han aplicado tres efectos de post procesado.

\begin{itemize}
\item \emph{Motion Blur} \cite{motion}. El objetivo de este efecto es hacer un difuminado en los objetos cuando la mirada del jugador se mueve rápidamente. La técnica transmite el jugador sensación de velocidad y hace una semejanza con el mundo real.

\item \emph{Z-Blur}. El efecto provoca un enfoque de los objetos cercanos al jugador, i difumina los objetos más alejados.

\item \emph{Lens Flare} (figura \ref{fig:lensflares}). Al mirar el cielo en dirección al Sol con una cámara, estas tienen un reflejo. Esta técnica imita este efecto provocados por las lentes de las cámaras.
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figures/development/lensflares.eps}
\end{center}
\emph{\caption{Efecto de lens flare en el juego}\label{fig:lensflares}}
\end{figure}

\subsection{Física}
En el apartado de física se ha utilizado la librería PhysX \cite{physx} de Nvidia. Con esta librería se ha desarrollado toda la parte de colisiones y interacciones con los diferentes elementos que conforman el juego, tanto el escenario como los personajes animados.

Para ello se ha creado un \emph{wrapper} para encapsular toda la parte de la librería útil para el proyecto, adaptándolo a nuestras necesidades. Con la encapsulación, nos ha permitido desarrollar todos los movimientos físicos y colisiones entre personajes y los diferentes elementos estáticos o interactivos del escenario.

Con la librería de física también se ha hecho uso de los \emph{triggers} físicos que incorpora, aunque el \emph{trigger} lógico, donde hay todo el código de \emph{gameplay}, está hecho mediante Lua.

Se ha utilizado los rayos que permite PhysX para la gestión y el control de la cámara principal del juego. Así, mediante testeo de rayos, podemos saber si hay objetos que obstaculizen la visión de la cámara y, tomar las decisiones necesarias para que siempre se vea el jugador y no quede oculto por diferentes objetos.

Las áreas de colisión también han sido utilizadas para el comportamiento de los enemigos. Las áreas de colisión nos permiten saber si hay enemigos cerca de otro enemigo, y así el personaje no jugador poder tomar las decisiones oportunas en su comportamiento.

\subsubsection{Escenario de pruebas}

Debido a la gestión por procesos de toda la aplicación, se ha creado una pequeña escena de test (figura \ref{fig:physx_test_scene}) para realizar el correcto desarrollo y testeo de todas las físicas del juego.

En este escenario de pruebas se han podido probar situaciones como:
\begin{itemize}
\item Muros de colisiones.
\item Controladores (\emph{controllers} en PhysX) para los personajes animados.
\item Escaleras con diferentes alturas de peldaños.
\item Elementos dinámicos como, por ejemplo, pelotas.
\item Objetos fijos al escenario y objetos dinámicos.
\item Colisiones entre diferentes grupos de colisión.
\item Puente dinámico.
\end{itemize}

Una de las pruebas más exhaustivas a hacer ha sido la reacción del jugador delante de todas las situaciones físicas. De esta manera, se ha podido configurar posteriormente para el juego final.

Otra de las pruebas más grandes ha sido crear un puente dinámico, es decir, que reaccione al paso del jugador por encima de él. Finalmente, el puente no se ha incluido en el juego.

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{figures/development/physx_test_scene.eps}
\end{center}
\emph{\caption{Escena de test de físicas}\label{fig:physx_test_scene}}
\end{figure}


\subsection{Inteligencia Artificial}
Para el juego de \emph{hack 'n' slash} inicialmente se planteó una senzilla inteligencia artificial. Durante el desarrollo del juego, cada vez se le fue dando más importancia a otorgar a los enemigos un comportamiento lógico mostrando que se comportan de una forma inteligente.

Para generar esos comportamientos inteligentes se han utilizado las técnicas de máquinas de estados y los \emph{steering behaviors}.

\subsubsection{Máquinas de estados}
Cada personaje está gestionado por dos máquinas de estados diferentes. Por una parte, una máquina de estados lógica donde se gestionan los diferentes estados relacionados con el comportamiento de los personajes. Por otro lado, una máquina de estados gráfica que permite la gestión de todos los estados animados, animaciones, de forma cómoda y sencilla.

El motivo de tener dos máquinas de estados diferentes es por facilitar el desarrollo, permitiendo, además, poder gestionar con un estado lógico varios estados gráficos. Por ejemplo, por un estado de reposo del personaje, poder tener diferentes animaciones de \emph{idle} a ejecutar.

El uso de la máquina de estados también nos permite commutar entre el estado actual de un personaje con sus estados anteriores, facilitando así las commutaciones entre ellos y poder tener un registro de lo que ha hecho y qué hará.

\subsubsection{Steering Behaviors}
En los juegos, el objtetivo principal de los enemigos es alcanzar al jugador. Por este motivo y para permitir crear los movimientos de los enemigos, se ha implementado \emph{steering behaviors}. 

Los \emph{steering behaviors} son un conjunto de algoritmos de inteligencia artificial que simulan el comportamiento de movimiento de agentes para que parezcan autónomos y permiten tomar decisiones según la interacción con los demás elementos del entorno. Estos comportamientos dan cierto grado de flexibilidad y facilidad para permitir mover los diferentes enemigos por el escenario evitando las obstrucciones, sean móviles o no.

Los comportamientos implementados son básicos y permiten ir a una posición determinada, perseguir a un objetivo, evitar colisiones, mantener cierta separación con el resto de enemigos,...

La flexibilidad de estos comportamientos recae en la posibilidad de añadir o quitar comportamientos con mucha facilidad. Los comportamientos pueden combinarse a la vez, así por ejemplo, poder perseguir al jugador y al mismo tiempo mantener cierta separación con el resto de enemigos para así, poder realizar ataques fácilmente.

La filosofía de los \emph{steering behaviors} que se han diseñado es de obtener una fuerza, un vector resultante de ese comportamiento, y finalmente sumarlos todos evitando sobrepasar siempre una fuerza resultante máxima. Los pesos permiten indicar qué cantidad de esa fuerza se aplica. Finalmente se aplican unos límites para que los personajes no se muevan de forma brusca o llegando a sobrepasar el escenario.

La gran desventaja de estos comportamientos es la combinación de ellos, los cuales pueden producir movimientos no muy adecuados para realizar algún ataque o simplemente dirigirse contra el jugador. Para solucionar el problema, se ha utilizado pesos para los comportamientos para determinar el grado de importancia y así permitir priorizar unos comportamientos u otros.

Otro de los problemas que hay estos algoritmos es ajustar todos los parámetros que estos procesan de manera que el movimiento de los agentes sean claros y correctos.

\subsubsection{Escenario de pruebas}
Para hacer pruebas de inteligencia artificial se ha desarrollado un pequeño escenario de pruebas (figura \ref{fig:test_ia}). Para agilizar la programación del escenario se ha programado con OpenGL.

En el escenario se probó diferentes comportamientos para los enemigos, como por ejemplo perseguir, escuchar o proximidad entre enemigos. También se hicieron pruebas de cámaras inteligentes funcionando con raíles, para ver como podría funcionar en el juego.

\begin{figure}
\begin{center}
\includegraphics[scale=0.3]{figures/development/test_ia.eps}
\end{center}
\emph{\caption{Escena de test de de inteligencia artificial}\label{fig:test_ia}}
\end{figure}

\subsection{Scripting}
El lenguaje de \emph{scripting} utilizado para le juego ha sido Lua \cite{lua}. Ya que la gran desventaja del lenguaje es no trabajar con clases, se ha utilizado como Luabind \cite{luabind} como solución a la encapsulación de clases en Lua.

Con este lenguaje de \emph{scripting} se ha implementado parte del \emph{gameplay} del juego, como por ejemplo los \emph{triggers}.

\subsection{Audio}

Para la gestión de sonido y música se ha utilizado la librería Wwise \cite{wwise} de Audiokinetic. La librería es de pago menos para Windows que es gratuita si el producto final es de uso no comercial. Wwise se utiliza en multitud de juegos actuales, entre ellos \emph{Mass Effect 3} \cite{ME3}, \emph{Assassin's Creed II} \cite{AC2}, \emph{inFamous 2} \cite{infamous} y \emph{Batman: Arkham City} \cite{batman}, entre otros.

Wwise funciona mediante eventos y bancos de sonido. En los bancos de sonido es donde residen todas las pistas de audio y los eventos son instrucciones sobre las pistas de audio. La creación de estos dos elementos se hace mediante el editor que lleva la propia librería (figura \ref{fig:wwise_editor}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{figures/development/wwise_editor.eps}
\end{center}
\emph{\caption{Editor de Wwise con el proyecto del juego}\label{fig:wwise_editor}}
\end{figure}

También se ha hecho uso de los RTPCs (\emph{Real-Time Parameter Controls}). Los RTPCs son curvas asociadas a un audio que, a partir de un parámetro, se puede modificar el sonido en tiempo real. Se han utilizado para poder modificar el volumen del sonido y de la música en cualquier momento. 

\subsection{Tools}

Se han hecho diferentes herramientas para el fácil y ágil desarrollo de algunas partes del juego. Así pues, se han hecho la herramientas: Particle Editor, GUI Editor y 3ds Max Exporter.

\subsubsection{Particle Editor} \label{sec:particleeditor}
Durante el desarrollo del juego, se ha llevado a cabo un simple editor de partículas (figura \ref{fig:particle_editor}) para poder generar las partículas de una forma más ágil, rápida y visual. Está hecho con MFC (\emph{Microsoft Foundation Class}).

El editor permite modificar todos los parámetros de un sistema de partículas en tiempo real. Al mismo tiempo, se puede ejecutar el sistema de partículas creado en diferentes tipos de emisores (tipo punto, caja, esfer, anillo, línea).

La herramienta permite generar sistemas de partículas distintos y guardarlos en un fichero XML preparado para ser leído directamente por el motor del juego.

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{figures/development/particle_editor.eps}
\end{center}
\emph{\caption{Particle Editor}\label{fig:particle_editor}}
\end{figure}

\subsubsection{GUI Editor}

Se ha desarrollado un editor (figura \ref{fig:gui_editor}) para poder hacer los menús del juego de una forma senzilla y rápida. Como el \emph{Particle Editor} (sección \ref{sec:particleeditor}), está hecho con MFC.

El editor permite poner todos los controles de los que dispone (botones, imágenes,...) mediante \emph{drag and drop}. Además, se puede modificar las propiedades de todos los controles que conforman la ventana, pudiendo personalizar totalmente la ventana de una forma visual.

La herramienta permite generar ventanas para trabajar con toda la GUI del juego a la vez y, también, guardar toda la información en ficheros XML que son leídos por el motor.

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{figures/development/gui_editor.eps}
\end{center}
\emph{\caption{GUI Editor}\label{fig:gui_editor}}
\end{figure}

\subsubsection{3ds Max Exporter}
Como Autodesk 3ds Max se ha utilizado como editor de niveles ha sido conveniente hacer una herramienta que pudiera exportar toda la información referente al escenario. Así pues, esta herramienta tiene las siguientes funcionalidades:

\begin{itemize}
\item Exportar toda una escena, o una parte de ella.
\item Definir los tipos de ementos que conforman la escena.
\item Definir y exportar toda la información sobre las luces del escenario.
\item definir y exportar raíles para cámaras.
\item Definir la física de los objetos y exportarla.
\item Definir y exportar las texturas del terreno.
\end{itemize}

\subsubsection{Viewer}
Se ha desarrollado un visor de elementos. Este visor permite cargar modelos, tanto estáticos como animados, y así poder apreciar como se ve dentro del motor. Esta herramienta está especialmente diseñada para los artistas para que pudiesen probar los modelos generados al momento. Así se agiliza el trabajo.